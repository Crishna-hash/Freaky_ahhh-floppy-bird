<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy (Your Version)</title>
<style>
  :root{
    --bg:#70c5ce;
    --ground:#c2b280;
    --panel:bg(white);
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(#70c5ce,#9be6ef);display:flex;align-items:center;justify-content:center}
  .wrap{width:100%;max-width:540px;padding:16px;box-sizing:border-box}
  .ui{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .title{font-weight:700;color:#05394a}
  .controls{display:flex;gap:8px;align-items:center}
  button {padding:8px 10px;border-radius:8px;border:0;background:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.06);cursor:pointer}
  #canvas{width:100%;height:auto;border-radius:12px;display:block;box-shadow:0 20px 60px rgba(2,8,20,0.2)}
  .overlay{position:relative;margin-top:8px}
  .info{display:flex;justify-content:space-between;margin-top:8px;color:#033;}
  .centerMsg{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;color:#022;pointer-events:none}
  .btnSmall{padding:6px 8px;font-size:14px}
  .footer{margin-top:10px;font-size:13px;color:#033; text-align:center}
</style>
</head>
<body>
  <div class="wrap">
    <div class="ui">
      <div class="title">Flappy â€” custom edition</div>
      <div class="controls">
        <button id="musicBtn" class="btnSmall">â–¶ Music</button>
        <button id="muteBtn" class="btnSmall">ðŸ”Š</button>
        <button id="resetBtn" class="btnSmall">Reset Best</button>
      </div>
    </div>

    <canvas id="canvas" width="480" height="640"></canvas>

    <div class="overlay" aria-hidden="false">
      <div class="centerMsg" id="centerMsg" style="display:none">
        <h2 id="centerTitle">Get ready</h2>
        <div id="centerSub" style="font-size:14px;color:#045"></div>
        <div style="margin-top:8px"><button id="startBtn">Start</button></div>
      </div>
    </div>

    <div class="info">
      <div>Score: <strong id="score">0</strong></div>
      <div>Best: <strong id="best">0</strong></div>
    </div>

    <div class="footer">
      Controls: Tap/click or Space / ArrowUp. Replace images & audio inside <code>assets/</code>.
    </div>
  </div>

<script>
/*
  Flappy Bird clone (single file)
  Drop your assets in /assets/ (see below).
  Controls: click/tap, space, ArrowUp.
*/

/* ===================== ASSET NAMES (place in assets/ folder) =====================
- assets/bird.png        (recommended 48x36 or similar, transparent)
- assets/pipe.png        (single pipe texture; we flip vertically for top pipe)
- assets/bg.png          (optional background image)
- assets/ground.png      (optional ground texture)
- assets/jump.wav        (sound when bird flaps)
- assets/hit.wav         (sound when bird collides / dies)
- assets/point.wav       (sound when passing a pipe)
- assets/music.mp3       (looping background music; will only play after user starts)
=================================================================================*/

/* ---------- Config ---------- */
const CONFIG = {
  gravity: 0.6,
  flapImpulse: -10.5,
  pipeGap: 140,
  pipeWidth: 72,
  pipeInterval: 1500, // ms between pipe spawns
  pipeSpeed: 2.8,
  birdX: 100,
  groundHeight: 120
};

/* ---------- Canvas ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

/* ---------- UI refs ---------- */
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const centerMsg = document.getElementById('centerMsg');
const centerTitle = document.getElementById('centerTitle');
const centerSub = document.getElementById('centerSub');
const startBtn = document.getElementById('startBtn');
const musicBtn = document.getElementById('musicBtn');
const muteBtn = document.getElementById('muteBtn');
const resetBtn = document.getElementById('resetBtn');

/* ---------- Game state ---------- */
let birdImg = new Image();
let pipeImg = new Image();
let bgImg = new Image();
let groundImg = new Image();

birdImg.src = 'assets/bird.png';
pipeImg.src = 'assets/pipe.png';
bgImg.src = 'assets/bg.png';        // optional; if not provided nothing is drawn
groundImg.src = 'assets/ground.png';// optional

// Audio
let jumpSound = new Audio('assets/jump.wav');
let hitSound = new Audio('assets/hit.wav');
let pointSound = new Audio('assets/point.wav');
let music = new Audio('assets/music.mp3');
music.loop = true;

// default audio behavior if files missing will fail silently; you can replace files

// localStorage best
const STORAGE_KEY = 'flappy_best_v1';
let best = Number(localStorage.getItem(STORAGE_KEY) || 0);
bestEl.innerText = best;

/* ---------- internal variables ---------- */
let bird = { x: CONFIG.birdX, y: H/2, vy: 0, rotation: 0 };
let pipes = []; // each pipe: {x, gapY, passed}
let lastPipeTime = 0;
let score = 0;
let running = false;
let gameOver = false;
let lastFrame = 0;
let muted = false;
let musicPlaying = false;

/* ---------- helpers ---------- */
function resizeCanvasToDisplay() {
  // keep base internal resolution fixed; scale CSS only for responsive
  const parent = canvas.parentElement;
  const maxW = Math.min(parent.clientWidth, 540);
  canvas.style.width = maxW + 'px';
  canvas.style.height = (maxW * canvas.height / canvas.width) + 'px';
}
window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

function playSound(audio) {
  if(muted) return;
  try { audio.currentTime = 0; audio.play(); } catch(e) { /* autoplay policy */ }
}

/* ---------- game logic ---------- */
function resetGame() {
  bird.y = H/2; bird.vy = 0; bird.rotation = 0;
  pipes = []; lastPipeTime = performance.now();
  score = 0; scoreEl.innerText = score;
  running = false; gameOver = false;
  centerTitle.innerText = 'Get ready';
  centerSub.innerText = 'Tap / Click or press Space to flap';
  centerMsg.style.display = 'block';
}

function startGame() {
  centerMsg.style.display = 'none';
  running = true;
  lastFrame = performance.now();
  lastPipeTime = performance.now();
  loop(lastFrame);
}

function spawnPipe() {
  const gap = CONFIG.pipeGap;
  const minY = 60;
  const maxY = H - CONFIG.groundHeight - minY - gap;
  const gapY = minY + Math.random() * (maxY - minY);
  pipes.push({ x: W + 10, gapY: gapY, passed: false });
}

function flap() {
  if(gameOver) {
    // restart on flap
    resetGame();
    startGame();
    return;
  }
  bird.vy = CONFIG.flapImpulse;
  playSound(jumpSound);
}

function update(dt) {
  // bird physics
  bird.vy += CONFIG.gravity;
  bird.y += bird.vy;
  bird.rotation = Math.max(Math.min(bird.vy / 12, 0.8), -0.8);

  // spawn pipes
  if(performance.now() - lastPipeTime > CONFIG.pipeInterval) {
    spawnPipe();
    lastPipeTime = performance.now();
  }

  // move pipes
  for(let p of pipes) {
    p.x -= CONFIG.pipeSpeed;
    // score when passed
    if(!p.passed && p.x + CONFIG.pipeWidth < bird.x) {
      p.passed = true;
      score += 1;
      scoreEl.innerText = score;
      playSound(pointSound);
    }
  }
  // remove offscreen pipes
  pipes = pipes.filter(p => p.x > -CONFIG.pipeWidth - 20);

  // ground collision
  if(bird.y + 14 >= H - CONFIG.groundHeight) {
    // hit ground
    triggerGameOver();
  }
  // ceiling clamp
  if(bird.y < 0) { bird.y = 0; bird.vy = 0; }

  // pipe collision: check bounding boxes
  for(let p of pipes) {
    const pipeTopBottom = p.gapY;
    const pipeLeft = p.x;
    const pipeRight = p.x + CONFIG.pipeWidth;
    const birdLeft = bird.x - 18;
    const birdRight = bird.x + 18;
    const birdTop = bird.y - 12;
    const birdBottom = bird.y + 12;

    // top pipe rectangle: from y=0 to gapY
    if(rectsIntersect(birdLeft, birdTop, birdRight, birdBottom, pipeLeft, 0, pipeRight, pipeTopBottom)) {
      triggerGameOver(); break;
    }
    // bottom pipe rectangle: from gapY+gap to bottom-ground
    const gapBottom = p.gapY + CONFIG.pipeGap;
    if(rectsIntersect(birdLeft, birdTop, birdRight, birdBottom, pipeLeft, gapBottom, pipeRight, H - CONFIG.groundHeight)) {
      triggerGameOver(); break;
    }
  }
}

function rectsIntersect(l1,t1,r1,b1, l2,t2,r2,b2) {
  return !(r1 < l2 || l1 > r2 || b1 < t2 || t1 > b2);
}

function triggerGameOver() {
  if(gameOver) return;
  gameOver = true; running = false;
  playSound(hitSound);
  centerTitle.innerText = 'Game Over';
  centerSub.innerText = 'Tap to restart';
  centerMsg.style.display = 'block';
  if(score > best) {
    best = score; localStorage.setItem(STORAGE_KEY, best); bestEl.innerText = best;
  }
}

/* ---------- rendering ---------- */
function draw() {
  // clear
  ctx.clearRect(0,0,W,H);

  // background image or gradient
  if(bgImg.complete && bgImg.naturalWidth !== 0) {
    // stretch bg
    ctx.drawImage(bgImg, 0, 0, W, H);
  } else {
    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#70c5ce');
    g.addColorStop(1, '#9be6ef');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }

  // pipes
  for(let p of pipes) {
    // top pipe (flipped vertically)
    if(pipeImg.complete && pipeImg.naturalWidth !== 0) {
      // draw top (flip)
      ctx.save();
      ctx.translate(p.x + CONFIG.pipeWidth/2, p.gapY/2);
      ctx.scale(1,-1);
      ctx.drawImage(pipeImg, -CONFIG.pipeWidth/2, - (p.gapY/2 + 0), CONFIG.pipeWidth, p.gapY);
      ctx.restore();
      // bottom pipe
      const bottomH = H - CONFIG.groundHeight - (p.gapY + CONFIG.pipeGap);
      ctx.drawImage(pipeImg, p.x, p.gapY + CONFIG.pipeGap, CONFIG.pipeWidth, bottomH);
    } else {
      // fallback drawn rectangles
      ctx.fillStyle = '#2ecc71';
      ctx.fillRect(p.x, 0, CONFIG.pipeWidth, p.gapY);
      ctx.fillRect(p.x, p.gapY + CONFIG.pipeGap, CONFIG.pipeWidth, H - CONFIG.groundHeight - (p.gapY + CONFIG.pipeGap));
    }
  }

  // ground (if provided)
  if(groundImg.complete && groundImg.naturalWidth !== 0) {
    ctx.drawImage(groundImg, 0, H - CONFIG.groundHeight, W, CONFIG.groundHeight);
  } else {
    ctx.fillStyle = '#c2b280';
    ctx.fillRect(0, H - CONFIG.groundHeight, W, CONFIG.groundHeight);
  }

  // bird (simple rotated draw)
  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.rotate(bird.rotation);
  if(birdImg.complete && birdImg.naturalWidth !== 0) {
    // center the bird image (assume approx 48x36)
    const bw = birdImg.width, bh = birdImg.height;
    ctx.drawImage(birdImg, -bw/2, -bh/2);
  } else {
    // fallback: draw a circle
    ctx.fillStyle = '#ffdd57';
    ctx.beginPath(); ctx.ellipse(0,0,18,14,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.fillRect(6, -2, 6, 4);
  }
  ctx.restore();

  // HUD handled by DOM elements (score)
}

/* ---------- main loop ---------- */
function loop(timestamp) {
  const dt = timestamp - lastFrame;
  lastFrame = timestamp;
  if(running) {
    update(dt);
  }
  draw();
  requestAnimationFrame(loop);
}

/* ---------- events ---------- */
canvas.addEventListener('click', (e) => {
  // determine where clicked: if game over or not running: start / restart
  if(!running && !gameOver) {
    startGame();
    flap();
    return;
  }
  flap();
});

startBtn.addEventListener('click', ()=> {
  startGame();
});
document.addEventListener('keydown', (e) => {
  if(e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    if(!running && !gameOver) { startGame(); flap(); return; }
    flap();
  }
});

musicBtn.addEventListener('click', () => {
  // user gesture to play music; toggle
  if(!musicPlaying) {
    music.play().catch(()=>{/* might be blocked */});
    musicPlaying = true; musicBtn.innerText = 'â¸ Music';
  } else {
    music.pause(); musicPlaying = false; musicBtn.innerText = 'â–¶ Music';
  }
});
muteBtn.addEventListener('click', () => {
  muted = !muted;
  muteBtn.innerText = muted ? 'ðŸ”‡' : 'ðŸ”Š';
});
resetBtn.addEventListener('click', () => {
  best = 0; localStorage.removeItem(STORAGE_KEY); bestEl.innerText = best;
});

/* ---------- utility start ---------- */
resetGame();
requestAnimationFrame(loop);

/* ---------- pre-load safe resizing adjustments ---------- */
function safeInit() {
  // adjust internal H/W if device pixel ratio large
  const ratio = window.devicePixelRatio || 1;
  // keep the internal canvas size as set; CSS scales it. If you want HiDPI rendering, uncomment below.
  // canvas.width = Math.floor(canvas.width * ratio); canvas.height = Math.floor(canvas.height * ratio);
  resizeCanvasToDisplay();
}
safeInit();

/* ---------- end of script ---------- */
</script>
</body>
</html>